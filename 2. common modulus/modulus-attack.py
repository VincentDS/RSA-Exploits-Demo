def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a

def longToString(n):
    return binascii.unhexlify("%x" % n)

import binascii

def coprime(a, b):
    return gcd(a, b) == 1

def egcd(a, b):
    x, lastX = 0, 1
    y, lastY = 1, 0
    while (b != 0):
        q = a // b
        a, b = b, a % b
        x, lastX = lastX - q * x, x
        y, lastY = lastY - q * y, y
    return (lastX, lastY)

def modinv(a, m):
    x, y = egcd(a, m)
    return x % m

def modulus_attack(n,e,c):
    n = n[0]
    c1 = c[0]
    c2 = c[1]
    x,y = egcd(e[0],e[1])
    if x < 0:
        x = -x
        c1 = modinv(c1,n)
    if y < 0:
        y = -y
        c2 = modinv(c2,n)
    return pow(c1, x, n) * pow(c2, y, n) % n

if __name__ == '__main__':
    nlist = list()
    elist = list()
    clist = list()

    with open('keys.txt') as f:
        while True:
            n = f.readline()[4:]
            if n == '':
                break
            e = f.readline()[4:]
            c = f.readline()[4:]
            f.readline()
            nlist.append(long(n,10))
            elist.append(long(e,10))
            clist.append(long(c,10))

    print "n1 and n2 the same? " + str(nlist[0] == nlist[1])
    print "e1 and e2 coprime? " + str(coprime(elist[0],elist[1])) + '\n'
    print "Starting Common Modulus Attack...\n"
    plaintext = modulus_attack(nlist, elist, clist)
    print longToString(plaintext)
