import binascii

def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a

def coprime(a, b):
    return gcd(a, b) == 1

def find_invpow(x,n):
    high = 1
    while high ** n < x:
        high *= 2
    low = high/2
    while low < high:
        mid = (low + high) // 2
        if low < mid and mid**n < x:
            low = mid
        elif high > mid and mid**n > x:
            high = mid
        else:
            return mid
    return mid + 1

def longToString(n):
    return binascii.unhexlify("%x" % n)

def chinese_remainder(n, a):
    sum = 0
    prod = reduce(lambda a, b: a*b, n)

    for n_i, a_i in zip(n, a):
        p = prod / n_i
        sum += a_i * mul_inv(p, n_i) * p
    return sum % prod


def mul_inv(a, b):
    b0 = b
    x0, x1 = 0, 1
    if b == 1: return 1
    while a > 1:
        q = a / b
        a, b = b, a%b
        x0, x1 = x1 - q * x0, x0
    if x1 < 0: x1 += b0
    return x1


if __name__ == '__main__':
    nlist = list()
    elist = list()
    clist = list()

    with open('keys.txt') as f:
        while True:
            n = f.readline()[4:]
            if n == '':
                break
            e = f.readline()[4:]
            c = f.readline()[4:]
            f.readline()
            nlist.append(long(n,10))
            elist.append(long(e,10))
            clist.append(long(c,10))

    print "n1 and n2 coprime? " + str(coprime(nlist[0],nlist[1]))
    print "n1 and n3 coprime? " + str(coprime(nlist[0],nlist[2]))
    print "n2 and n3 coprime? " + str(coprime(nlist[1],nlist[2])) + '\n'
    print "Starting Low Public Exponent Attack...\n"

    x = chinese_remainder(nlist, clist)
    print "x = "+ str(x) + '\n'
    print longToString(find_invpow(x,3))

